<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>é’±åŒ…æ‰©å±•æµ‹è¯• dApp - æ”¹è¿›ç‰ˆæ¶ˆæ¯ä¼ é€’</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.8.0/dist/ethers.umd.min.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        min-height: 100vh;
      }

      .container {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        padding: 30px;
        box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
      }

      h1 {
        text-align: center;
        margin-bottom: 30px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .status {
        padding: 10px;
        margin: 10px 0;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        background: rgba(255, 255, 255, 0.1);
      }

      .success {
        background: rgba(76, 175, 80, 0.3);
      }

      .error {
        background: rgba(244, 67, 54, 0.3);
      }

      .warning {
        background: rgba(255, 193, 7, 0.3);
      }

      button {
        background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
        border: none;
        color: white;
        padding: 12px 24px;
        margin: 8px;
        border-radius: 25px;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      }

      button:disabled {
        background: rgba(128, 128, 128, 0.5);
        cursor: not-allowed;
        transform: none;
      }

      input {
        width: 100%;
        padding: 10px;
        margin: 8px 0;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        font-size: 16px;
      }

      input::placeholder {
        color: rgba(255, 255, 255, 0.7);
      }

      .button-group {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
        margin: 20px 0;
      }

      .logs {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        padding: 15px;
        margin-top: 20px;
        max-height: 300px;
        overflow-y: auto;
        font-family: "Courier New", monospace;
        font-size: 14px;
      }

      .log-entry {
        margin: 5px 0;
        padding: 5px;
        border-left: 3px solid #4ecdc4;
        padding-left: 10px;
      }

      .section {
        margin: 30px 0;
        padding: 20px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .section h3 {
        margin-top: 0;
        color: #4ecdc4;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ğŸš€ é’±åŒ…æ‰©å±•æµ‹è¯• dApp</h1>
      <p style="text-align: center; opacity: 0.9">
        ä½¿ç”¨ @webext-core/messaging æ”¹è¿›ç‰ˆæ¶ˆæ¯ä¼ é€’ç³»ç»Ÿ
      </p>

      <div id="status" class="status warning">
        <strong>çŠ¶æ€:</strong> ç­‰å¾…è¿æ¥é’±åŒ…...
      </div>

      <div class="section">
        <h3>ğŸ”— è¿æ¥é’±åŒ…</h3>
        <div class="button-group">
          <button onclick="connectWallet()">è¿æ¥é’±åŒ…</button>
          <button onclick="checkConnection()">æ£€æŸ¥è¿æ¥</button>
          <button onclick="getAccounts()">è·å–è´¦æˆ·</button>
          <button onclick="getChainId()">è·å–é“¾ ID</button>
          <button onclick="getNetworkVersion()">è·å–ç½‘ç»œç‰ˆæœ¬</button>
        </div>
      </div>

      <div class="section">
        <h3>ğŸ’° ä½™é¢å’Œäº¤æ˜“</h3>
        <input
          type="text"
          id="balanceAddress"
          placeholder="è¾“å…¥è¦æŸ¥è¯¢ä½™é¢çš„åœ°å€ï¼ˆç•™ç©ºä½¿ç”¨å½“å‰è´¦æˆ·ï¼‰"
        />
        <div class="button-group">
          <button onclick="getBalance()">è·å–ä½™é¢</button>
          <button onclick="sendTestTransaction()">å‘é€æµ‹è¯•äº¤æ˜“</button>
        </div>
      </div>

      <div class="section">
        <h3>âœï¸ ç­¾ååŠŸèƒ½</h3>
        <input
          type="text"
          id="messageToSign"
          placeholder="è¾“å…¥è¦ç­¾åçš„æ¶ˆæ¯"
          value="Hello, Web3!"
        />
        <div class="button-group">
          <button onclick="signMessage()">ç­¾åæ¶ˆæ¯</button>
          <button onclick="personalSign()">Personal Sign</button>
          <button onclick="signTypedData()">ç­¾åç±»å‹åŒ–æ•°æ®</button>
        </div>
      </div>

      <div class="section">
        <h3>ğŸ” SIWE æµ‹è¯•</h3>
        <input
          type="text"
          id="domainInput"
          placeholder="åŸŸå (ä¾‹å¦‚: example.com)"
          value="localhost:8080"
        />
        <input
          type="text"
          id="statementInput"
          placeholder="å£°æ˜ (å¯é€‰)"
          value="Sign in to our app"
        />
        <div class="button-group">
          <button onclick="generateSiweMessage()">ç”Ÿæˆ SIWE æ¶ˆæ¯</button>
          <button onclick="signSiweMessage()">ç­¾å SIWE æ¶ˆæ¯</button>
          <button onclick="verifySiweSignature()">éªŒè¯ SIWE ç­¾å</button>
        </div>
        <textarea
          id="siweMessage"
          rows="6"
          style="
            width: 100%;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
          "
          placeholder="SIWE æ¶ˆæ¯å°†åœ¨è¿™é‡Œæ˜¾ç¤º"
        ></textarea>
        <div
          id="siweSignature"
          style="
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: monospace;
            word-break: break-all;
          "
        ></div>
      </div>

      <div class="section">
        <h3>ğŸŒ ç½‘ç»œæ“ä½œ</h3>
        <div class="button-group">
          <button onclick="switchToMainnet()">åˆ‡æ¢åˆ°ä¸»ç½‘</button>
          <button onclick="switchToPolygon()">åˆ‡æ¢åˆ° Polygon</button>
          <button onclick="switchToCyber()">åˆ‡æ¢åˆ° Cyber æµ‹è¯•ç½‘</button>
          <button onclick="addCustomNetwork()">æ·»åŠ è‡ªå®šä¹‰ç½‘ç»œ</button>
        </div>
      </div>

      <div class="section">
        <h3>ğŸ”„ äº‹ä»¶ç›‘å¬</h3>
        <div class="button-group">
          <button onclick="setupEventListeners()">è®¾ç½®äº‹ä»¶ç›‘å¬å™¨</button>
          <button onclick="removeEventListeners()">ç§»é™¤äº‹ä»¶ç›‘å¬å™¨</button>
        </div>
      </div>

      <div class="section">
        <h3>ğŸ§ª å‹åŠ›æµ‹è¯•</h3>
        <div class="button-group">
          <button onclick="runStressTest()">è¿è¡Œå‹åŠ›æµ‹è¯•</button>
          <button onclick="clearLogs()">æ¸…é™¤æ—¥å¿—</button>
        </div>
      </div>

      <div class="logs" id="logs">
        <div class="log-entry"><strong>ğŸ“‹ æ—¥å¿—è¾“å‡º:</strong></div>
      </div>
    </div>

    <script>
      let accounts = [];
      let currentChainId = null;

      function log(message, type = "info") {
        const logs = document.getElementById("logs");
        const entry = document.createElement("div");
        entry.className = "log-entry";

        const timestamp = new Date().toLocaleTimeString();
        const emoji =
          type === "error"
            ? "âŒ"
            : type === "success"
            ? "âœ…"
            : type === "warning"
            ? "âš ï¸"
            : "â„¹ï¸";

        entry.innerHTML = `<span style="opacity: 0.7">[${timestamp}]</span> ${emoji} ${message}`;
        logs.appendChild(entry);
        logs.scrollTop = logs.scrollHeight;

        console.log(`[${timestamp}] ${message}`);
      }

      function updateStatus(message, type = "warning") {
        const status = document.getElementById("status");
        status.className = `status ${type}`;
        status.innerHTML = `<strong>çŠ¶æ€:</strong> ${message}`;
      }

      async function connectWallet() {
        log("ğŸ”— å°è¯•è¿æ¥é’±åŒ…...");

        if (typeof window.ethereum === "undefined") {
          log("âŒ æœªæ£€æµ‹åˆ°é’±åŒ…æ‰©å±•", "error");
          updateStatus("æœªæ£€æµ‹åˆ°é’±åŒ…æ‰©å±•", "error");
          return;
        }

        try {
          const startTime = performance.now();
          accounts = await window.ethereum.request({
            method: "eth_requestAccounts",
          });
          const endTime = performance.now();

          log(
            `âœ… é’±åŒ…è¿æ¥æˆåŠŸ! è´¦æˆ·: ${accounts[0]} (è€—æ—¶: ${(
              endTime - startTime
            ).toFixed(2)}ms)`,
            "success"
          );
          updateStatus(`å·²è¿æ¥: ${accounts[0]}`, "success");

          // è·å–å½“å‰é“¾ID
          currentChainId = await window.ethereum.request({
            method: "eth_chainId",
          });
          log(
            `ğŸŒ å½“å‰é“¾ID: ${currentChainId} (${parseInt(currentChainId, 16)})`,
            "success"
          );
        } catch (error) {
          log(`âŒ è¿æ¥å¤±è´¥: ${error.message}`, "error");
          updateStatus(`è¿æ¥å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function checkConnection() {
        log("ğŸ” æ£€æŸ¥è¿æ¥çŠ¶æ€...");

        if (typeof window.ethereum === "undefined") {
          log("âŒ æœªæ£€æµ‹åˆ°é’±åŒ…æ‰©å±•", "error");
          return;
        }

        try {
          const startTime = performance.now();
          const accounts = await window.ethereum.request({
            method: "eth_accounts",
          });
          const endTime = performance.now();

          if (accounts.length > 0) {
            log(
              `âœ… å·²è¿æ¥è´¦æˆ·: ${accounts[0]} (è€—æ—¶: ${(
                endTime - startTime
              ).toFixed(2)}ms)`,
              "success"
            );
            updateStatus(`å·²è¿æ¥: ${accounts[0]}`, "success");
          } else {
            log("âš ï¸ æœªè¿æ¥ä»»ä½•è´¦æˆ·", "warning");
            updateStatus("æœªè¿æ¥", "warning");
          }
        } catch (error) {
          log(`âŒ æ£€æŸ¥è¿æ¥å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function getAccounts() {
        log("ğŸ‘¥ è·å–è´¦æˆ·åˆ—è¡¨...");

        try {
          const startTime = performance.now();
          const accounts = await window.ethereum.request({
            method: "eth_accounts",
          });
          const endTime = performance.now();

          log(
            `âœ… è´¦æˆ·åˆ—è¡¨ (è€—æ—¶: ${(endTime - startTime).toFixed(
              2
            )}ms): ${JSON.stringify(accounts)}`,
            "success"
          );
        } catch (error) {
          log(`âŒ è·å–è´¦æˆ·å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function getChainId() {
        log("ğŸ”— è·å–é“¾ID...");

        try {
          const startTime = performance.now();
          const chainId = await window.ethereum.request({
            method: "eth_chainId",
          });
          const endTime = performance.now();

          log(
            `âœ… é“¾ID (è€—æ—¶: ${(endTime - startTime).toFixed(
              2
            )}ms): ${chainId} (åè¿›åˆ¶: ${parseInt(chainId, 16)})`,
            "success"
          );
          currentChainId = chainId;
        } catch (error) {
          log(`âŒ è·å–é“¾IDå¤±è´¥: ${error.message}`, "error");
        }
      }

      async function getNetworkVersion() {
        log("ğŸŒ è·å–ç½‘ç»œç‰ˆæœ¬...");

        try {
          const startTime = performance.now();
          const version = await window.ethereum.request({
            method: "net_version",
          });
          const endTime = performance.now();

          log(
            `âœ… ç½‘ç»œç‰ˆæœ¬ (è€—æ—¶: ${(endTime - startTime).toFixed(
              2
            )}ms): ${version}`,
            "success"
          );
        } catch (error) {
          log(`âŒ è·å–ç½‘ç»œç‰ˆæœ¬å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function getBalance() {
        log("ğŸ’° è·å–ä½™é¢...");

        try {
          const address =
            document.getElementById("balanceAddress").value || accounts[0];
          if (!address) {
            log("âŒ è¯·å…ˆè¿æ¥é’±åŒ…æˆ–è¾“å…¥åœ°å€", "error");
            return;
          }

          const startTime = performance.now();
          const balance = await window.ethereum.request({
            method: "eth_getBalance",
            params: [address, "latest"],
          });
          const endTime = performance.now();

          const balanceInEth = parseInt(balance, 16) / Math.pow(10, 18);
          log(
            `âœ… åœ°å€ ${address} çš„ä½™é¢ (è€—æ—¶: ${(endTime - startTime).toFixed(
              2
            )}ms): ${balance} wei (${balanceInEth} ETH)`,
            "success"
          );
        } catch (error) {
          log(`âŒ è·å–ä½™é¢å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function sendTestTransaction() {
        log("ğŸ’¸ å‘é€æµ‹è¯•äº¤æ˜“...");

        if (!accounts.length) {
          log("âŒ è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        try {
          const startTime = performance.now();
          const txHash = await window.ethereum.request({
            method: "eth_sendTransaction",
            params: [
              {
                from: accounts[0],
                to: "0x742d35Cc1e13dC0b5b7c5e3e8f2a3B85a8e0e0f1",
                value: "0x1", // 1 wei
                gas: "0x5208", // 21000
                gasPrice: "0x9184e72a000", // 10 gwei
              },
            ],
          });
          const endTime = performance.now();

          log(
            `âœ… äº¤æ˜“å‘é€æˆåŠŸ (è€—æ—¶: ${(endTime - startTime).toFixed(
              2
            )}ms)! äº¤æ˜“å“ˆå¸Œ: ${txHash}`,
            "success"
          );
        } catch (error) {
          log(`âŒ å‘é€äº¤æ˜“å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function signMessage() {
        log("âœï¸ ç­¾åæ¶ˆæ¯...");

        if (!accounts.length) {
          log("âŒ è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        try {
          const message = document.getElementById("messageToSign").value;
          const startTime = performance.now();
          const signature = await window.ethereum.request({
            method: "eth_sign",
            params: [accounts[0], message],
          });
          const endTime = performance.now();

          log(
            `âœ… æ¶ˆæ¯ç­¾åæˆåŠŸ (è€—æ—¶: ${(endTime - startTime).toFixed(
              2
            )}ms)! ç­¾å: ${signature}`,
            "success"
          );
        } catch (error) {
          log(`âŒ ç­¾åå¤±è´¥: ${error.message}`, "error");
        }
      }

      async function personalSign() {
        log("âœï¸ Personal Sign...");

        if (!accounts.length) {
          log("âŒ è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        try {
          const message = document.getElementById("messageToSign").value;
          const startTime = performance.now();
          const signature = await window.ethereum.request({
            method: "personal_sign",
            params: [message, accounts[0]],
          });
          const endTime = performance.now();

          log(
            `âœ… Personal Sign æˆåŠŸ (è€—æ—¶: ${(endTime - startTime).toFixed(
              2
            )}ms)! ç­¾å: ${signature}`,
            "success"
          );
        } catch (error) {
          log(`âŒ Personal Sign å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function signTypedData() {
        log("âœï¸ ç­¾åç±»å‹åŒ–æ•°æ®...");

        if (!accounts.length) {
          log("âŒ è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        try {
          const typedData = {
            types: {
              EIP712Domain: [
                { name: "name", type: "string" },
                { name: "version", type: "string" },
              ],
              Message: [{ name: "content", type: "string" }],
            },
            primaryType: "Message",
            domain: {
              name: "Test dApp",
              version: "1",
            },
            message: {
              content: "Hello, typed data!",
            },
          };

          const startTime = performance.now();
          const signature = await window.ethereum.request({
            method: "eth_signTypedData_v4",
            params: [accounts[0], JSON.stringify(typedData)],
          });
          const endTime = performance.now();

          log(
            `âœ… ç±»å‹åŒ–æ•°æ®ç­¾åæˆåŠŸ (è€—æ—¶: ${(endTime - startTime).toFixed(
              2
            )}ms)! ç­¾å: ${signature}`,
            "success"
          );
        } catch (error) {
          log(`âŒ ç±»å‹åŒ–æ•°æ®ç­¾åå¤±è´¥: ${error.message}`, "error");
        }
      }

      async function switchToMainnet() {
        log("ğŸŒ åˆ‡æ¢åˆ°ä»¥å¤ªåŠä¸»ç½‘...");
        await switchNetwork("0x1");
      }

      async function switchToPolygon() {
        log("ğŸŒ åˆ‡æ¢åˆ° Polygon...");
        await switchNetwork("0x89");
      }

      async function switchToCyber() {
        log("ğŸŒ åˆ‡æ¢åˆ° Cyber æµ‹è¯•ç½‘...");
        await switchNetwork("0x6a4f668");
      }

      async function switchNetwork(chainId) {
        try {
          const startTime = performance.now();
          await window.ethereum.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId }],
          });
          const endTime = performance.now();

          log(
            `âœ… ç½‘ç»œåˆ‡æ¢æˆåŠŸ (è€—æ—¶: ${(endTime - startTime).toFixed(
              2
            )}ms)! æ–°é“¾ID: ${chainId}`,
            "success"
          );
          currentChainId = chainId;
        } catch (error) {
          log(`âŒ ç½‘ç»œåˆ‡æ¢å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function addCustomNetwork() {
        log("ğŸŒ æ·»åŠ è‡ªå®šä¹‰ç½‘ç»œ...");

        try {
          const startTime = performance.now();
          await window.ethereum.request({
            method: "wallet_addEthereumChain",
            params: [
              {
                chainId: "0xf00",
                chainName: "Custom Test Network",
                rpcUrls: ["https://custom-rpc.example.com"],
                nativeCurrency: {
                  name: "Custom Token",
                  symbol: "CTK",
                  decimals: 18,
                },
                blockExplorerUrls: ["https://custom-explorer.example.com"],
              },
            ],
          });
          const endTime = performance.now();

          log(
            `âœ… è‡ªå®šä¹‰ç½‘ç»œæ·»åŠ æˆåŠŸ (è€—æ—¶: ${(endTime - startTime).toFixed(
              2
            )}ms)!`,
            "success"
          );
        } catch (error) {
          log(`âŒ æ·»åŠ è‡ªå®šä¹‰ç½‘ç»œå¤±è´¥: ${error.message}`, "error");
        }
      }

      function setupEventListeners() {
        log("ğŸ”„ è®¾ç½®äº‹ä»¶ç›‘å¬å™¨...");

        if (typeof window.ethereum === "undefined") {
          log("âŒ æœªæ£€æµ‹åˆ°é’±åŒ…æ‰©å±•", "error");
          return;
        }

        // è´¦æˆ·å˜æ›´äº‹ä»¶
        window.ethereum.on("accountsChanged", (accounts) => {
          log(`ğŸ”„ è´¦æˆ·å˜æ›´äº‹ä»¶: ${JSON.stringify(accounts)}`, "warning");
          updateStatus(
            accounts.length ? `å·²è¿æ¥: ${accounts[0]}` : "æœªè¿æ¥",
            accounts.length ? "success" : "warning"
          );
        });

        // é“¾å˜æ›´äº‹ä»¶
        window.ethereum.on("chainChanged", (chainId) => {
          log(
            `ğŸ”„ é“¾å˜æ›´äº‹ä»¶: ${chainId} (åè¿›åˆ¶: ${parseInt(chainId, 16)})`,
            "warning"
          );
          currentChainId = chainId;
        });

        // è¿æ¥äº‹ä»¶
        window.ethereum.on("connect", (connectInfo) => {
          log(`ğŸ”„ è¿æ¥äº‹ä»¶: ${JSON.stringify(connectInfo)}`, "warning");
        });

        // æ–­å¼€è¿æ¥äº‹ä»¶
        window.ethereum.on("disconnect", (error) => {
          log(`ğŸ”„ æ–­å¼€è¿æ¥äº‹ä»¶: ${error.message}`, "warning");
          updateStatus("å·²æ–­å¼€è¿æ¥", "error");
        });

        log("âœ… äº‹ä»¶ç›‘å¬å™¨è®¾ç½®æˆåŠŸ", "success");
      }

      function removeEventListeners() {
        log("ğŸ”„ ç§»é™¤äº‹ä»¶ç›‘å¬å™¨...");

        if (typeof window.ethereum === "undefined") {
          log("âŒ æœªæ£€æµ‹åˆ°é’±åŒ…æ‰©å±•", "error");
          return;
        }

        window.ethereum.removeAllListeners();
        log("âœ… æ‰€æœ‰äº‹ä»¶ç›‘å¬å™¨å·²ç§»é™¤", "success");
      }

      async function runStressTest() {
        log("ğŸ§ª å¼€å§‹å‹åŠ›æµ‹è¯•...");

        if (!accounts.length) {
          log("âŒ è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        const testCount = 50;
        let successCount = 0;
        let totalTime = 0;

        for (let i = 0; i < testCount; i++) {
          try {
            const startTime = performance.now();
            await window.ethereum.request({ method: "eth_accounts" });
            const endTime = performance.now();

            successCount++;
            totalTime += endTime - startTime;

            if (i % 10 === 9) {
              log(
                `ğŸ§ª å‹åŠ›æµ‹è¯•è¿›åº¦: ${
                  i + 1
                }/${testCount} (æˆåŠŸ: ${successCount})`,
                "warning"
              );
            }
          } catch (error) {
            log(`âŒ å‹åŠ›æµ‹è¯•ç¬¬ ${i + 1} æ¬¡å¤±è´¥: ${error.message}`, "error");
          }
        }

        const avgTime = totalTime / successCount;
        log(
          `ğŸ§ª å‹åŠ›æµ‹è¯•å®Œæˆ! æˆåŠŸ: ${successCount}/${testCount}, å¹³å‡å“åº”æ—¶é—´: ${avgTime.toFixed(
            2
          )}ms`,
          "success"
        );
      }

      function clearLogs() {
        const logs = document.getElementById("logs");
        logs.innerHTML =
          '<div class="log-entry"><strong>ğŸ“‹ æ—¥å¿—è¾“å‡º:</strong></div>';
        log("ğŸ§¹ æ—¥å¿—å·²æ¸…é™¤");
      }

      // SIWE ç›¸å…³å‡½æ•°
      let currentSiweMessage = "";
      let currentSiweSignature = "";

      function generateSiweMessage() {
        log("ğŸ” ç”Ÿæˆ SIWE æ¶ˆæ¯...");

        if (!accounts.length) {
          log("âŒ è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        const domain =
          document.getElementById("domainInput").value || "localhost:8080";
        const statement =
          document.getElementById("statementInput").value ||
          "Sign in to our app";
        const address = accounts[0];
        const chainId = currentChainId ? parseInt(currentChainId, 16) : 1;

        // ç”Ÿæˆéšæœº nonce
        const nonce = Math.random().toString(36).substring(2, 15);

        // å½“å‰æ—¶é—´
        const issuedAt = new Date().toISOString();

        // 1å°æ—¶åè¿‡æœŸ
        const expirationTime = new Date(
          Date.now() + 60 * 60 * 1000
        ).toISOString();

        // æ„å»º SIWE æ¶ˆæ¯
        const siweMessage = `${domain} wants you to sign in with your Ethereum account:
${address}

${statement}

URI: https://${domain}
Version: 1
Chain ID: ${chainId}
Nonce: ${nonce}
Issued At: ${issuedAt}
Expiration Time: ${expirationTime}`;

        currentSiweMessage = siweMessage;

        document.getElementById("siweMessage").value = siweMessage;
        document.getElementById("siweSignature").innerHTML = "";

        log(
          `âœ… SIWE æ¶ˆæ¯å·²ç”Ÿæˆ (åœ°å€: ${address}, é“¾ID: ${chainId})`,
          "success"
        );
      }

      async function signSiweMessage() {
        log("ğŸ” ç­¾å SIWE æ¶ˆæ¯...");

        if (!accounts.length) {
          log("âŒ è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        if (!currentSiweMessage) {
          log("âŒ è¯·å…ˆç”Ÿæˆ SIWE æ¶ˆæ¯", "error");
          return;
        }

        try {
          const startTime = performance.now();

          // ä½¿ç”¨ personal_sign æ–¹æ³•ï¼ˆSIWE æ ‡å‡†æ¨èï¼‰
          const signature = await window.ethereum.request({
            method: "personal_sign",
            params: [currentSiweMessage, accounts[0]],
          });

          const endTime = performance.now();

          currentSiweSignature = signature;

          document.getElementById("siweSignature").innerHTML = `
            <strong>ç­¾å:</strong><br>
            <span style="word-break: break-all;">${signature}</span><br>
            <small style="opacity: 0.7;">é•¿åº¦: ${signature.length} å­—ç¬¦</small>
          `;

          log(
            `âœ… SIWE æ¶ˆæ¯ç­¾åæˆåŠŸ (è€—æ—¶: ${(endTime - startTime).toFixed(
              2
            )}ms)`,
            "success"
          );
          log(`ğŸ” ç­¾å: ${signature}`, "success");
        } catch (error) {
          log(`âŒ SIWE ç­¾åå¤±è´¥: ${error.message}`, "error");
        }
      }

      async function verifySiweSignature() {
        log("ğŸ” éªŒè¯ SIWE ç­¾å...");

        if (!currentSiweMessage || !currentSiweSignature) {
          log("âŒ è¯·å…ˆç”Ÿæˆå¹¶ç­¾å SIWE æ¶ˆæ¯", "error");
          return;
        }

        if (!accounts.length) {
          log("âŒ è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        try {
          // ä½¿ç”¨ç®€å•çš„å®¢æˆ·ç«¯éªŒè¯
          const isValid = await verifyPersonalSignature(
            currentSiweMessage,
            currentSiweSignature,
            accounts[0]
          );

          if (isValid) {
            log("âœ… SIWE ç­¾åéªŒè¯æˆåŠŸï¼", "success");
          } else {
            log("âŒ SIWE ç­¾åéªŒè¯å¤±è´¥ï¼", "error");
          }
        } catch (error) {
          log(`âŒ SIWE ç­¾åéªŒè¯å‡ºé”™: ${error.message}`, "error");
        }
      }

      // ç®€å•çš„å®¢æˆ·ç«¯ç­¾åéªŒè¯å‡½æ•°
      async function verifyPersonalSignature(
        message,
        signature,
        expectedAddress
      ) {
        try {
          // ä½¿ç”¨ ethers.js è¿›è¡ŒéªŒè¯ï¼ˆå¦‚æœå¯ç”¨ï¼‰
          if (typeof ethers !== "undefined") {
            const recoveredAddress = ethers.verifyMessage(message, signature);
            return (
              recoveredAddress.toLowerCase() === expectedAddress.toLowerCase()
            );
          }

          // å¦‚æœæ²¡æœ‰ ethers.jsï¼Œä½¿ç”¨ Web3 æ–¹å¼éªŒè¯
          const msgHash = web3.utils.sha3(
            "\x19Ethereum Signed Message:\n" + message.length + message
          );
          const recoveredAddress = web3.eth.accounts.recover(
            msgHash,
            signature
          );
          return (
            recoveredAddress.toLowerCase() === expectedAddress.toLowerCase()
          );
        } catch (error) {
          console.error("éªŒè¯ç­¾åæ—¶å‡ºé”™:", error);

          // ç®€å•çš„æ£€æŸ¥ï¼šç¡®ä¿ç­¾åæ ¼å¼æ­£ç¡®
          if (!signature.startsWith("0x") || signature.length !== 132) {
            throw new Error("ç­¾åæ ¼å¼ä¸æ­£ç¡®");
          }

          // åŸºæœ¬æ£€æŸ¥é€šè¿‡ï¼Œä½†æ— æ³•å®Œå…¨éªŒè¯
          log("âš ï¸ æ— æ³•å®Œå…¨éªŒè¯ç­¾åï¼Œä½†æ ¼å¼çœ‹èµ·æ¥æ­£ç¡®", "warning");
          return true;
        }
      }

      // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥è¿æ¥
      window.addEventListener("load", () => {
        log("ğŸš€ é¡µé¢åŠ è½½å®Œæˆï¼Œæ£€æŸ¥é’±åŒ…è¿æ¥çŠ¶æ€...");
        checkConnection();
      });
    </script>
  </body>
</html>
